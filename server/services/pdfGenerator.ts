/**
 * PDF Generator Service
 * Generates customer statements and reports using pdfkit
 */

import PDFDocument from "pdfkit";
import fs from "fs";
import path from "path";

export interface StatementData {
  customerName: string;
  customerId?: string;
  phone?: string;
  address?: string;
  openingBalance: number;
  transactions: Array<{
    date: string;
    description: string;
    debit: number;
    credit: number;
    balance: number;
  }>;
  closingBalance: number;
  generatedAt: Date;
}

export class PDFGenerator {
  private static instance: PDFGenerator;

  static getInstance(): PDFGenerator {
    if (!this.instance) {
      this.instance = new PDFGenerator();
    }
    return this.instance;
  }

  /**
   * Generate customer statement PDF
   */
  async generateStatement(data: StatementData): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: "A4",
          margin: 50,
          info: {
            Title: `كشف حساب - ${data.customerName}`,
            Author: "RinaPro ERP",
          },
        });

        const chunks: Buffer[] = [];
        doc.on("data", (chunk) => chunks.push(chunk));
        doc.on("end", () => resolve(Buffer.concat(chunks)));
        doc.on("error", reject);

        // Header
        doc.fontSize(20).text("RinaPro Business ERP", { align: "center" });
        doc.moveDown(0.5);
        doc.fontSize(16).text("Customer Statement", { align: "center" });
        doc.moveDown(1);

        // Customer Info
        doc.fontSize(12);
        doc.text(`Customer: ${data.customerName}`, { align: "left" });
        if (data.customerId) doc.text(`ID: ${data.customerId}`);
        if (data.phone) doc.text(`Phone: ${data.phone}`);
        if (data.address) doc.text(`Address: ${data.address}`);
        doc.moveDown(0.5);
        doc.text(`Statement Date: ${data.generatedAt.toLocaleDateString("en-US")}`);
        doc.moveDown(1);

        // Opening Balance
        doc.fontSize(11).text(`Opening Balance: ${this.formatCurrency(data.openingBalance)}`, { align: "left" });
        doc.moveDown(1);

        // Transaction Table Header
        const tableTop = doc.y;
        const tableHeaders = ["Date", "Description", "Debit", "Credit", "Balance"];
        const colWidths = [80, 200, 70, 70, 80];
        
        let x = 50;
        doc.fontSize(10).font("Helvetica-Bold");
        tableHeaders.forEach((header, i) => {
          doc.text(header, x, tableTop, { width: colWidths[i], align: "left" });
          x += colWidths[i];
        });
        doc.moveTo(50, tableTop + 15).lineTo(550, tableTop + 15).stroke();
        doc.moveDown(1);

        // Transaction Rows
        doc.font("Helvetica");
        let y = doc.y;
        
        for (const tx of data.transactions) {
          if (y > 700) {
            doc.addPage();
            y = 50;
          }

          x = 50;
          doc.text(tx.date, x, y, { width: colWidths[0] });
          x += colWidths[0];
          doc.text(tx.description, x, y, { width: colWidths[1] });
          x += colWidths[1];
          doc.text(this.formatCurrency(tx.debit), x, y, { width: colWidths[2] });
          x += colWidths[2];
          doc.text(this.formatCurrency(tx.credit), x, y, { width: colWidths[3] });
          x += colWidths[3];
          doc.text(this.formatCurrency(tx.balance), x, y, { width: colWidths[4] });
          
          y += 20;
        }

        // Closing Balance
        doc.moveDown(2);
        doc.fontSize(12).font("Helvetica-Bold");
        doc.text(`Closing Balance: ${this.formatCurrency(data.closingBalance)}`, { align: "right" });

        // Footer
        doc.moveDown(3);
        doc.fontSize(9).font("Helvetica");
        doc.text("This is a computer-generated document.", { align: "center" });
        doc.text(`Generated by RinaPro ERP on ${new Date().toLocaleString()}`, { align: "center" });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Generate invoice PDF
   */
  async generateInvoice(data: {
    invoiceNumber: string;
    customerName: string;
    invoiceDate: Date;
    items: Array<{ description: string; quantity: number; unitPrice: number; total: number }>;
    totalAmount: number;
    paidAmount: number;
    remainingAmount: number;
  }): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: "A4",
          margin: 50,
          info: {
            Title: `Invoice ${data.invoiceNumber}`,
            Author: "RinaPro ERP",
          },
        });

        const chunks: Buffer[] = [];
        doc.on("data", (chunk) => chunks.push(chunk));
        doc.on("end", () => resolve(Buffer.concat(chunks)));
        doc.on("error", reject);

        // Header
        doc.fontSize(24).text("INVOICE", { align: "center" });
        doc.moveDown(0.5);
        doc.fontSize(12).text(`Invoice #: ${data.invoiceNumber}`, { align: "right" });
        doc.text(`Date: ${data.invoiceDate.toLocaleDateString()}`, { align: "right" });
        doc.moveDown(1);

        // Customer Info
        doc.fontSize(12).text(`Bill To:`, { underline: true });
        doc.text(data.customerName);
        doc.moveDown(1);

        // Items Table
        const tableTop = doc.y;
        const headers = ["Description", "Qty", "Unit Price", "Total"];
        const colWidths = [250, 50, 100, 100];
        
        let x = 50;
        doc.font("Helvetica-Bold");
        headers.forEach((header, i) => {
          doc.text(header, x, tableTop, { width: colWidths[i] });
          x += colWidths[i];
        });
        doc.moveTo(50, tableTop + 15).lineTo(550, tableTop + 15).stroke();
        
        doc.font("Helvetica");
        let y = tableTop + 25;
        
        for (const item of data.items) {
          x = 50;
          doc.text(item.description, x, y, { width: colWidths[0] });
          x += colWidths[0];
          doc.text(item.quantity.toString(), x, y, { width: colWidths[1] });
          x += colWidths[1];
          doc.text(this.formatCurrency(item.unitPrice), x, y, { width: colWidths[2] });
          x += colWidths[2];
          doc.text(this.formatCurrency(item.total), x, y, { width: colWidths[3] });
          y += 20;
        }

        // Totals
        doc.moveDown(2);
        const totalsX = 350;
        doc.text(`Subtotal: ${this.formatCurrency(data.totalAmount)}`, totalsX);
        doc.text(`Paid: ${this.formatCurrency(data.paidAmount)}`, totalsX);
        doc.font("Helvetica-Bold");
        doc.text(`Balance Due: ${this.formatCurrency(data.remainingAmount)}`, totalsX);

        // Footer
        doc.moveDown(3);
        doc.fontSize(10).font("Helvetica");
        doc.text("Thank you for your business!", { align: "center" });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Save PDF to file
   */
  async savePDF(buffer: Buffer, filename: string): Promise<string> {
    const outputDir = path.join(process.cwd(), "data", "pdfs");
    
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    const filepath = path.join(outputDir, filename);
    await fs.promises.writeFile(filepath, buffer);
    
    return filepath;
  }

  private formatCurrency(amount: number): string {
    return (amount / 100).toLocaleString("en-US", {
      style: "currency",
      currency: "SAR",
    });
  }
}

export const pdfGenerator = PDFGenerator.getInstance();
